pragma language_version >= 0.16 && <= 0.17;

import CompactStandardLibrary;

// Public state
export ledger bettedNumbers: Map<Uint<32>, Uint<32>>; // (Number -> Amount of bets)
export ledger winnerNumber: Uint<32>; // (Number)
export ledger bets: Set<Bytes<32>>; // (<Address + Number> Hash)
export ledger owner: ZswapCoinPublicKey;
export ledger aggregatedPayment: Map<Uint<32>, QualifiedCoinInfo>;

// Private State
witness secretKey(): Bytes<32>; // Function implemented in typescript

constructor() {
    owner = ownPublicKey();
    winnerNumber = 0;
}

export circuit placeBet(number: Uint<32>, tokens: CoinInfo): [] {
    // Use assert instead of if
    if (winnerNumber == 0) {
        const pk = ownPublicKey();
        const disclosedNumber = disclose(number);
        const disclosedPayment = disclose(tokens);
        receive(disclosedPayment);
        if (aggregatedPayment.size() == 0 ){
            aggregatedPayment.insertCoin(0 as Uint<32>, disclosedPayment, left<ZswapCoinPublicKey, ContractAddress>(pk));
        }
        const totalPayment = aggregatedPayment.lookup(0);
        const mergedPayment = mergeCoinImmediate(totalPayment, disclosedPayment);
        aggregatedPayment.remove(0);
        aggregatedPayment.insertCoin(0 as Uint<32>, mergedPayment, left<ZswapCoinPublicKey, ContractAddress>(pk));
        if (bettedNumbers.member(disclosedNumber)) {
            const amount: Uint<32> = bettedNumbers.lookup(disclosedNumber);
            bettedNumbers.insert(disclosedNumber, amount + 1 as Uint<32>);
            bets.insert(betEntry(disclose(secretKey()), disclosedNumber));
        } else {
            bettedNumbers.insert(disclosedNumber, 1);
            bets.insert(betEntry(disclose(secretKey()), disclosedNumber));
          }
    }
}

export circuit setWinner(number: Uint<32>): [] {
    const pk = ownPublicKey();
    assert(owner == pk, "Only owner can set the winner");
    winnerNumber = disclose(number);
}

circuit betEntry(sk: Bytes<32>, number: Uint<32>): Bytes<32> {
    const hashedNumber: Bytes<32> = persistentHash<[Bytes<32>, Uint<32>]>([pad(32, "number-domain"), number]);
    return persistentHash<Vector<3, Bytes<32>>>([pad(32, "commitment-domain"), sk, hashedNumber]);
}

// circuit send
//  (input: QualifiedCoinInfo,
//   recipient: Either<ZswapCoinPublicKey,
//   ContractAddress>, value: Uint<128>): SendResult;
